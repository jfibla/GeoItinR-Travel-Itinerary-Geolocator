wide <- tidyr::pivot_wider(tmp, names_from = field, values_from = value)
} else {
wide <- df
}
# Ensure consistent column order and headers
names(wide) <- ifelse(tolower(names(wide)) == "country", "country", toupper(names(wide)))
need <- c("country", "DOCUMENTATION", "LOCAL_TIME", "LANGUAGE", "INTERNET", "PLUGS", "CURRENCY")
for (nm in need) if (!nm %in% names(wide)) wide[[nm]] <- NA_character_
wide[, need]
}
# =====================
# 3. UI Rendering & Controls
# =====================
# Render a summary table of the trip data
output$trip_summary <- renderTable({
td <- current_td()
if (is.null(td)) return(NULL)
data.frame(
Places = nrow(td$places),
Stages = nrow(td$stages),
Hotels = nrow(td$hotels),
Points_of_Interest = nrow(td$interes),
Info_Entries = nrow(td$info)
)
})
# Render the INFO table in wide format with automatic language priority
output$info_table <- renderTable({
td <- current_td()
info_to_wide(td$info)
})
# Render the INFO table in wide format using a specific language
output$info_lang_table <- renderTable({
td <- current_td()
info_to_wide_lang(td$info, lcode = input$lang_code)
})
# Render the places table using DT with editable cells
output$places_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$places, editable = TRUE, options = list(pageLength = 5))
})
# Render the hotels table
output$hotels_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$hotels, editable = TRUE, options = list(pageLength = 5))
})
# Render the stages table
output$stages_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$stages, editable = TRUE, options = list(pageLength = 5))
})
# Render the points of interest table
output$interes_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$interes, editable = TRUE, options = list(pageLength = 5))
})
# Render the INFO table for editing
output$info_edit_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$info, editable = TRUE, options = list(pageLength = 5))
})
# Show modal dialog to edit INFO entries
observeEvent(input$edit_info_btn, {
showModal(modalDialog(
title = "Edit Country Info",
DT::dataTableOutput("info_edit_table"),
footer = modalButton("Close")
))
})
# =====================
# 4. Mapping & Geolocation
# =====================
output$trip_map <- renderLeaflet({
td <- current_td()
if (is.null(td)) return(NULL)
leaflet() %>%
addTiles(group = "Base Map") %>%
addProviderTiles("CartoDB.Positron", group = "Light") %>%
addProviderTiles("CartoDB.DarkMatter", group = "Dark") %>%
addProviderTiles("Esri.WorldImagery", group = "Satellite") %>%
addProviderTiles("OpenStreetMap.Mapnik", group = "OSM") %>%
addLayersControl(
baseGroups = c("Base Map", "Light", "Dark", "Satellite", "OSM"),
overlayGroups = c("Places", "Hotels", "Points of Interest"),
options = layersControlOptions(collapsed = FALSE)
) %>%
addCircleMarkers(
data = td$places,
lng = ~lon, lat = ~lat,
radius = 6, color = "#1f78b4", stroke = TRUE, fillOpacity = 0.8,
label = ~paste(ciudad, pais),
group = "Places"
) %>%
addCircleMarkers(
data = td$hotels,
lng = ~hotel_lon, lat = ~hotel_lat,
radius = 5, color = "#33a02c", stroke = TRUE, fillOpacity = 0.8,
label = ~hotel_name,
group = "Hotels"
) %>%
addCircleMarkers(
data = td$interes,
lng = ~lon, lat = ~lat,
radius = 4, color = "#ff7f00", stroke = TRUE, fillOpacity = 0.8,
label = ~descriptor,
group = "Points of Interest"
)
})
# Update map when trip data changes
observe({
td <- current_td()
leafletProxy("trip_map") %>% clearMarkers() %>% clearShapes()
if (!is.null(td$places) && nrow(td$places) > 0) {
leafletProxy("trip_map") %>%
addCircleMarkers(
data = td$places,
lng = ~lon, lat = ~lat,
radius = 6, color = "#1f78b4", stroke = TRUE, fillOpacity = 0.8,
label = ~paste(ciudad, pais),
group = "Places"
)
}
if (!is.null(td$hotels) && nrow(td$hotels) > 0) {
leafletProxy("trip_map") %>%
addCircleMarkers(
data = td$hotels,
lng = ~hotel_lon, lat = ~hotel_lat,
radius = 5, color = "#33a02c", stroke = TRUE, fillOpacity = 0.8,
label = ~hotel_name,
group = "Hotels"
)
}
if (!is.null(td$interes) && nrow(td$interes) > 0) {
leafletProxy("trip_map") %>%
addCircleMarkers(
data = td$interes,
lng = ~lon, lat = ~lat,
radius = 4, color = "#ff7f00", stroke = TRUE, fillOpacity = 0.8,
label = ~descriptor,
group = "Points of Interest"
)
}
})
# =====================
# 5. Wikipedia & OSM Integration
# =====================
# Fetch Wikipedia summary for a given title
get_wikipedia_summary <- function(title) {
url <- paste0("https://en.wikipedia.org/api/rest_v1/page/summary/", URLencode(title))
res <- try(jsonlite::fromJSON(url), silent = TRUE)
if (inherits(res, "try-error") || is.null(res$extract)) return(NA_character_)
res$extract
}
# Build Wikipedia URL from language and title
wiki_url_build <- function(lang, title) {
if (!nzchar(title)) return(NA_character_)
paste0("https://", lang, ".wikipedia.org/wiki/", utils::URLencode(title, reserved = TRUE))
}
# Perform Wikipedia opensearch and return top URLs
wiki_opensearch_urls <- function(lang, query, limit = 3, tmo = 3) {
if (!nzchar(query)) return(character(0))
url <- paste0("https://", lang, ".wikipedia.org/w/api.php")
req <- httr2::request(url) |>
httr2::req_url_query(action = "opensearch", search = query, limit = limit,
namespace = 0, format = "json") |>
httr2::req_timeout(tmo) |>
httr2::req_retry(max_tries = 2)
resp <- try(httr2::req_perform(req), silent = TRUE)
if (inherits(resp, "try-error")) return(character(0))
js <- try(httr2::resp_body_json(resp, simplifyVector = TRUE), silent = TRUE)
if (inherits(js, "try-error") || length(js) < 4) return(character(0))
as.character(js[[4]] %||% character(0))
}
# Perform geosearch on Wikipedia
wiki_geosearch <- function(lang, lat, lon, radius = 150, limit = 15, tmo = 3) {
if (is.na(lat) || is.na(lon)) return(data.frame())
url <- paste0("https://", lang, ".wikipedia.org/w/api.php")
req <- httr2::request(url) |>
httr2::req_url_query(
action = "query", list = "geosearch",
gscoord = paste0(lat, "|", lon),
gsradius = radius, gslimit = limit, format = "json"
) |>
httr2::req_timeout(tmo) |>
httr2::req_retry(max_tries = 2)
resp <- try(httr2::req_perform(req), silent = TRUE)
if (inherits(resp, "try-error")) return(data.frame())
js <- try(httr2::resp_body_json(resp, simplifyVector = TRUE), silent = TRUE)
if (inherits(js, "try-error")) return(data.frame())
items <- try(js$query$geosearch, silent = TRUE)
if (inherits(items, "try-error") || is.null(items) || !nrow(as.data.frame(items))) return(data.frame())
df <- as.data.frame(items)
df$url <- vapply(df$title, function(t) wiki_url_build(lang, t), character(1))
df
}
# Build bounding box around coordinates
bbox_around <- function(lat, lon, radius_m = 250) {
dlat <- radius_m / 111320
dlon <- radius_m / (111320 * cos(lat * pi / 180))
c(lon - dlon, lat - dlat, lon + dlon, lat + dlat)
}
# Collect OSM candidates near a location
collect_osm_candidates <- function(res, lat, lon) {
layers <- list(res$osm_points, res$osm_polygons, res$osm_multipolygons, res$osm_lines)
layers <- Filter(function(x) !is.null(x) && nrow(x) > 0, layers)
if (!length(layers)) return(NULL)
out <- list()
ref_pt <- sf::st_sfc(sf::st_point(c(lon, lat)), crs = 4326)
for (x in layers) {
g <- sf::st_geometry(x)
if (length(g) == 0) next
ctr <- suppressWarnings(sf::st_centroid(g))
d <- try(as.numeric(sf::st_distance(ctr, ref_pt)), silent = TRUE)
if (inherits(d, "try-error") || length(d) != nrow(x)) d <- rep(Inf, nrow(x))
attrs <- sf::st_drop_geometry(x)
attrs$..dist <- d
out[[length(out) + 1]] <- attrs
}
if (!length(out)) return(NULL)
cand <- do.call(rbind, out)
cand <- cand[order(cand$..dist), , drop = FALSE]
head(cand, 80)
}
# Pick best URL from OSM attributes
osm_pick_url <- function(attrs) {
nm <- names(attrs)
w   <- if ("website"         %in% nm) attrs[["website"]]         else NA
cw  <- if ("contact:website" %in% nm) attrs[["contact:website"]] else NA
url <- if ("url"             %in% nm) attrs[["url"]]             else NA
cu  <- if ("contact:url"     %in% nm) attrs[["contact:url"]]     else NA
out <- first_nonempty(w, cw, url, cu)
if (!is.na(out)) return(out)
wp  <- if ("wikipedia" %in% nm) attrs[["wikipedia"]] else NA
if (!is.na(wp) && nzchar(wp) && grepl(":", wp, fixed = TRUE)) {
parts <- strsplit(wp, ":", fixed = TRUE)[[1]]
return(paste0("https://", parts[1], ".wikipedia.org/wiki/",
utils::URLencode(parts[2], reserved = TRUE)))
}
wd  <- if ("wikidata" %in% nm) attrs[["wikidata"]] else NA
if (!is.na(wd) && nzchar(wd)) return(paste0("https://www.wikidata.org/wiki/", wd))
NA_character_
}
# =====================
# 6. Editable Tables & Modals
# =====================
# Render editable tables for each data slot
output$places_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$places, editable = TRUE, options = list(pageLength = 5))
})
output$stages_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$stages, editable = TRUE, options = list(pageLength = 5))
})
output$hotels_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$hotels, editable = TRUE, options = list(pageLength = 5))
})
output$interes_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$interes, editable = TRUE, options = list(pageLength = 5))
})
output$info_edit_table <- DT::renderDataTable({
td <- current_td()
DT::datatable(td$info, editable = TRUE, options = list(pageLength = 5))
})
# Observe edits in each table and update reactive data
observeEvent(input$places_table_cell_edit, {
info <- input$places_table_cell_edit
td <- current_td()
td$places[info$row, info$col] <- info$value
trip_data(td)
})
observeEvent(input$stages_table_cell_edit, {
info <- input$stages_table_cell_edit
td <- current_td()
td$stages[info$row, info$col] <- info$value
trip_data(td)
})
observeEvent(input$hotels_table_cell_edit, {
info <- input$hotels_table_cell_edit
td <- current_td()
td$hotels[info$row, info$col] <- info$value
trip_data(td)
})
observeEvent(input$interes_table_cell_edit, {
info <- input$interes_table_cell_edit
td <- current_td()
td$interes[info$row, info$col] <- info$value
trip_data(td)
})
observeEvent(input$info_edit_table_cell_edit, {
info <- input$info_edit_table_cell_edit
td <- current_td()
td$info[info$row, info$col] <- info$value
trip_data(td)
})
# Show modal dialog to edit INFO entries
observeEvent(input$edit_info_btn, {
showModal(modalDialog(
title = "Edit Country Info",
DT::dataTableOutput("info_edit_table"),
footer = modalButton("Close")
))
})
# =====================
# 7. Utility Functions & Normalization
# =====================
# Normalize country name to lowercase alphanumeric
normalize_country <- function(name) {
name <- tolower(trimws(name))
name <- gsub("[^a-z]", "", name)
name
}
# Generate a unique place ID from city and country
generate_place_id <- function(city, country) {
paste0(normalize_country(country), "_", normalize_country(city))
}
# Add a new place to the trip data
add_place <- function(city, country, lat, lon, wiki = NA) {
td <- current_td()
new_place <- tibble::tibble(
place_id = generate_place_id(city, country),
ciudad = city, pais = country,
lat = lat, lon = lon, wikipedia = wiki
)
td$places <- dplyr::bind_rows(td$places, new_place)
trip_data(td)
}
# Coerce a value to match the type of a template
coerce_like <- function(value, template) {
if (is.numeric(template))      suppressWarnings(as.numeric(value))
else if (inherits(template, "Date")) as.Date(value)
else if (is.logical(template)) as.logical(value)
else                           as.character(value)
}
# Return the first existing column from a list of candidates
col_first_existing <- function(df, candidates, default = NA_character_) {
for (nm in candidates) if (nm %in% names(df)) return(df[[nm]])
rep(default, nrow(df))
}
# Return the first non-empty value from a list
first_nonempty <- function(...) {
xx <- unlist(list(...))
xx <- xx[!is.na(xx) & nzchar(as.character(xx))]
if (length(xx)) as.character(xx[1]) else NA_character_
}
# Normalize string: lowercase, trim, remove accents and special characters
norm_str <- function(x){
x <- tolower(trimws(as.character(x)))
x <- iconv(x, to = "ASCII//TRANSLIT")
gsub("[^a-z0-9]+", " ", x)
}
# =====================
# 8. Observers & Reactive Logic
# =====================
# Add a new place when the user clicks the button
observeEvent(input$add_place_btn, {
add_place(
city    = input$new_city,
country = input$new_country,
lat     = input$new_lat,
lon     = input$new_lon,
wiki    = input$new_wiki
)
})
# Reset the trip data to empty
observeEvent(input$reset_trip_btn, {
trip_data(empty_td())
})
# Load sample trip data from file
observeEvent(input$load_sample_btn, {
sample_data <- readRDS("sample_trip_data.rds")
trip_data(sample_data)
})
# Update language selection
observeEvent(input$lang_en, lang("en"))
observeEvent(input$lang_es, lang("es"))
observeEvent(input$lang_ca, lang("ca"))
# Update current day based on selected date
observeEvent(input$dia, {
if (!is.null(input$dia) && !is.na(input$dia)) current_day(as.Date(input$dia))
})
# Update map view when bounds change
observe({
b <- input$map_bounds
if (!is.null(b)) {
view_state$center <- c(
lng = as.numeric((b$west + b$east)/2),
lat = as.numeric((b$south + b$north)/2)
)
}
})
# Update zoom level
observe({
if (!is.null(input$map_zoom)) view_state$zoom <- as.numeric(input$map_zoom)
})
# Update UI titles based on selected language
observe({
session$sendCustomMessage("update-title", tr("title", lang()))
})
# Automatically select default day if current is invalid
observeEvent(etapas_exp(), {
rng <- dates_range()
if (is.null(rng)) return()
sel <- current_day()
if (is.null(sel) || is.na(sel) || sel < rng$min || sel > rng$max) current_day(rng$min)
shinyWidgets::updateAirDateInput(session, "dia", value = current_day(),
options = list(minDate = rng$min, maxDate = rng$max))
})
# Update city selector when trip data changes
observe({
td <- current_td()
updateSelectInput(session, "place_pick", choices = td$places$ciudad)
})
# Update map when trip data changes
observeEvent(trip_data(), {
redraw_map(do_zoom = TRUE)
})
# Update map when hotel or interest data changes
observeEvent(list(show_hotels_eff(), interes_markers()), {
redraw_map(do_zoom = FALSE)
})
# =====================
# 9. Export & Download Handlers
# =====================
# Build Excel payload from trip data
build_trip_xlsx <- function(td, lang_code = "en") {
# --- Places ---
places <- td$places
if (!"wikipedia" %in% names(places)) places$wikipedia <- NA_character_
if (!"ciudad" %in% names(places) && "city" %in% names(places)) places$ciudad <- places$city
if (!"pais"   %in% names(places) && "country" %in% names(places)) places$pais <- places$country
places$lat <- suppressWarnings(as.numeric(places$lat))
places$lon <- suppressWarnings(as.numeric(places$lon))
places_out <- places |>
dplyr::rename(city = ciudad, country = pais) |>
dplyr::select(place_id, city, country, lat, lon, wikipedia)
# --- Stages ---
st <- td$stages
desc_vec <- col_first_existing(st, c("description","descripció","descripción"))
medi_vec <- col_first_existing(st, c("medi","modo"))
ruta_vec <- col_first_existing(st, c("ruta","route","trayecto","trajeto","route_desc","ruta_text"))
for (nm in c("etapa","from_id","to_id","date")) if (!nm %in% names(st)) st[[nm]] <- NA
stages_out <- st |>
dplyr::mutate(description = desc_vec, medi = medi_vec, ruta = ruta_vec) |>
dplyr::select(etapa, from_id, to_id, date, description, medi, ruta)
# --- Hotels ---
hotels_out <- NULL
if (!is.null(td$hotels) && nrow(td$hotels)) {
h <- td$hotels
for (nm in c("hotel_name","hotel_link","details","hotel_lat","hotel_lon"))
if (!nm %in% names(h)) h[[nm]] <- if (grepl("_lat$|_lon$", nm)) NA_real_ else NA_character_
h$hotel_lat <- suppressWarnings(as.numeric(h$hotel_lat))
h$hotel_lon <- suppressWarnings(as.numeric(h$hotel_lon))
hotels_out <- h |> dplyr::select(place_id, hotel_name, hotel_link, details, hotel_lat, hotel_lon)
}
# --- Points of Interest ---
interes_out <- NULL
if (!is.null(td$interes) && nrow(td$interes)) {
inter <- td$interes
for (nm in c("descriptor","ciudad","pais","lat","lon","tipus","link","observacio"))
if (!nm %in% names(inter)) inter[[nm]] <- NA
inter$lat <- suppressWarnings(as.numeric(inter$lat))
inter$lon <- suppressWarnings(as.numeric(inter$lon))
interes_out <- inter |> dplyr::select(descriptor, ciudad, pais, lat, lon, tipus, link, observacio)
}
# --- Info (force wide format) ---
info_out <- NULL
if (!is.null(td$info) && nrow(td$info)) info_out <- info_to_wide(td$info)
Filter(Negate(is.null), list(
places  = places_out,
stages  = stages_out,
hotels  = hotels_out,
interes = interes_out,
info    = info_out
))
}
# Download handler for processed itinerary
output$download_itinerary_proc <- downloadHandler(
filename = function() {
base <- input$www_filename_proc %||% "itinerary_view"
base <- gsub("[^[:alnum:]_\\x2D ]+", "_", trimws(base))
paste0(base, ".xlsx")
},
content = function(file) {
td <- current_td(); if (is.null(td)) stop("No data loaded")
payload <- build_trip_xlsx(td)
if (!is.null(td$info) && nrow(td$info)) payload$info <- info_to_wide(td$info)
writexl::write_xlsx(payload, path = file)
}
)
# =====================
# 10. Final Server Closure
# =====================
}  # End of server function
shinyApp(ui, server)
runApp('Library/CloudStorage/Dropbox/GeoItinR_app/trip_app/app_m1.R')
runApp('Library/CloudStorage/Dropbox/GeoItinR_app/trip_app')
output$places_table <- DT::renderDT({
td <- current_td(); req(td); df <- td$places; if (is.null(df)) df <- data.frame()
DT::datatable(
df,
colnames = dt_headers(df, "places", lang()),
selection = if (isTRUE(input$allow_edit_process)) "multiple" else "none",
editable  = isTRUE(input$allow_edit_process),
escape    = TRUE,
options   = list(pageLength = 8)
)
})
runApp('Library/CloudStorage/Dropbox/GeoItinR_app/trip_app')
runApp('Library/CloudStorage/Dropbox/GeoItinR_app/trip_app')
library(shiny); runApp('app2.R')
